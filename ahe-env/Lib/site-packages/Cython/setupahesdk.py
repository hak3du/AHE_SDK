import os

sdk_root = "ahe_sdk"
ahe_pkg = os.path.join(sdk_root, "ahe")

files = {
    "README.md": """\
# Adaptive Hashing Encryption (AHE) SDK v9.5

Modular SDK implementing Adaptive Hashing Encryption v9.5 with PQC.

Run main.py to test encryption and decryption.

""",

    "setup.py": """\
from setuptools import setup, find_packages

setup(
    name="ahe_sdk",
    version="0.9.5",
    description="Adaptive Hashing Encryption SDK with PQC support",
    author="The Architect Beyond Time",
    packages=find_packages(),
    install_requires=[
        "pycryptodome",
        "argon2-cffi",
        "liboqs-python"
    ],
    python_requires='>=3.8',
)
""",

    os.path.join("ahe", "_init_.py"): "",

    os.path.join("ahe", "config.py"): """\
ENTROPY_WARN_THRESHOLD_LOW = 3.5
ENTROPY_WARN_THRESHOLD_HIGH = 4.75
AES_KEY_SIZE = 32

HASH_ALGORITHMS = [
    "sha256",
    "sha512",
    "sha3_256",
    "sha3_512"
]

PQC_FAST_KEMS = ["Kyber512", "Kyber768", "ML-KEM-512", "ML-KEM-768"]
PQC_STRONG_KEMS = ["Kyber1024", "sntrup761", "ML-KEM-1024"]
""",

    os.path.join("ahe", "utils.py"): """\
import hashlib
import math
import time
import uuid
import platform
import os
import socket

from base64 import urlsafe_b64encode, urlsafe_b64decode
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

from argon2.low_level import hash_secret_raw, Type
import hmac

from .config import AES_KEY_SIZE, ENTROPY_WARN_THRESHOLD_LOW, ENTROPY_WARN_THRESHOLD_HIGH, HASH_ALGORITHMS

def calculate_shannon_entropy(data: bytes) -> float:
    if not data:
        return 0.0
    freq = {b: data.count(b)/len(data) for b in set(data)}
    return -sum(p * math.log2(p) for p in freq.values())

def get_environment_entropy() -> bytes:
    raw = (
        str(uuid.getnode()) +
        str(platform.system()) +
        str(platform.release()) +
        str(os.cpu_count()) +
        str(os.getpid()) +
        str(time.time()) +
        str(socket.gethostname())
    ).encode()
    return hashlib.sha3_512(raw).digest()

def detect_anomaly(input_data: str, entropy_score: float) -> tuple:
    suspicious_chars = "0123456789+/=\\n"
    reasons = []
    if any(c in input_data for c in suspicious_chars):
        reasons.append("suspicious characters detected")
    if entropy_score < ENTROPY_WARN_THRESHOLD_LOW or entropy_score > ENTROPY_WARN_THRESHOLD_HIGH:
        reasons.append("entropy out of range")
    return (len(reasons) > 0), reasons

def hash_stage(data: bytes, algo: str) -> bytes:
    h = hashlib.new(algo)
    h.update(data)
    return h.digest()

def aes_encrypt(message: str, key: bytes) -> dict:
    nonce = get_random_bytes(12)
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    ciphertext, tag = cipher.encrypt_and_digest(message.encode())
    return {
        "ciphertext": urlsafe_b64encode(ciphertext).decode(),
        "nonce": urlsafe_b64encode(nonce).decode(),
        "tag": urlsafe_b64encode(tag).decode()
    }

def aes_decrypt(bundle: dict, key: bytes) -> str:
    nonce = urlsafe_b64decode(bundle["nonce"])
    tag = urlsafe_b64decode(bundle["tag"])
    ciphertext = urlsafe_b64decode(bundle["ciphertext"])
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    return cipher.decrypt_and_verify(ciphertext, tag).decode()

def shorten_bytes_for_display(data: bytes, length=10):
    if len(data) <= length:
        return data.hex()
    return data[:length].hex() + "..."
""",

    os.path.join("ahe", "pqc.py"): """\
import oqs
import random
import time

from .config import PQC_FAST_KEMS, PQC_STRONG_KEMS

def pqc_keypair(kem_name: str):
    kem = oqs.KeyEncapsulation(kem_name)
    public_key = kem.generate_keypair()
    return kem, public_key

def pqc_encapsulate(kem, public_key: bytes):
    return kem.encap_secret(public_key)

def pqc_decapsulate(kem, ciphertext: bytes):
    return kem.decap_secret(ciphertext)

def select_pqc_kem(anomaly: bool):
    if anomaly:
        return PQC_STRONG_KEMS.copy()
    else:
        return PQC_FAST_KEMS.copy()

def try_pqc_kems(anomaly: bool):
    pqc_candidates = select_pqc_kem(anomaly)
    random.shuffle(pqc_candidates)
    return pqc_candidates
""",
}

# Create directories
os.makedirs(ahe_pkg, exist_ok=True)

# Write all files
for filename, content in files.items():
    filepath = os.path.join(sdk_root, filename)
    folder = os.path.dirname(filepath)
    if folder and not os.path.exists(folder):
        os.makedirs(folder)
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content)

print(f"Created modular SDK in '{sdk_root}/' folder with config, utils, pqc modules.")
print("Next, I will provide the rest of the code files (encrypt.py, decrypt.py, main.py).")